# -*- coding: utf-8 -*-
"""BBL434_Assignment-2_Naman_Kohli.ipynb.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ygiW9xHQ5r-IPrZdWo5cXZIs39R2KxoJ
"""

import numpy as np
import csv

def read_fasta(seq):
    dna = []
    with open(seq, 'r') as f:
        for i in f.readlines():
            y = i.strip()
            if y.startswith('>'):
                continue
            dna.append(y)
    return ''.join(dna)


def read_csv(csvf):
    gap_open_pen = 0
    gap_ext_pen = 0
    score_mat = []
    with open(csvf, 'r') as f:
        x = csv.reader(f)
        c = 0
        for row in x:
            if c == 0:
                gap_open_pen = row[0]
            elif c == 1:
                gap_ext_pen = row[0]
            else:
                score_mat.append(row)
            c += 1

    fin_score_mat = [[int(i) for i in sub_list] for sub_list in score_mat]
    return int(gap_open_pen), int(gap_ext_pen), fin_score_mat


def affine_global_alignment(seq1, seq2, gap_open, gap_extend, score_mat):

    # Define alphabet order (must match matrix order)
    alphabet = ['A', 'C', 'G', 'T']
    index = {char: i for i, char in enumerate(alphabet)}

    n = len(seq1)
    m = len(seq2)

    # Initialize matrices
    M = np.full((n+1, m+1), -np.inf)
    X = np.full((n+1, m+1), -np.inf)
    Y = np.full((n+1, m+1), -np.inf)

    M[0][0] = 0

    # Initialize first column
    for i in range(1, n+1):
        Y[i][0] = gap_open + (i-1)*gap_extend

    # Initialize first row
    for j in range(1, m+1):
        X[0][j] = gap_open + (j-1)*gap_extend

    # Fill matrices
    for i in range(1, n+1):
        for j in range(1, m+1):

            # Substitution score
            s = score_mat[index[seq1[i-1]]][index[seq2[j-1]]]

            M[i][j] = max(
                M[i-1][j-1],
                X[i-1][j-1],
                Y[i-1][j-1]
            ) + s

            X[i][j] = max(
                M[i][j-1] + gap_open,
                X[i][j-1] + gap_extend
            )

            Y[i][j] = max(
                M[i-1][j] + gap_open,
                Y[i-1][j] + gap_extend
            )

    # Final score
    final_score = max(M[n][m], X[n][m], Y[n][m])

    align1 = ""
    align2 = ""

    i, j = n, m

    current_matrix = np.argmax([M[n][m], X[n][m], Y[n][m]])

    while i > 0 or j > 0:

        if current_matrix == 0:  # M
            s = score_mat[index[seq1[i-1]]][index[seq2[j-1]]]

            if M[i][j] == M[i-1][j-1] + s:
                current_matrix = 0
            elif M[i][j] == X[i-1][j-1] + s:
                current_matrix = 1
            else:
                current_matrix = 2

            align1 = seq1[i-1] + align1
            align2 = seq2[j-1] + align2
            i -= 1
            j -= 1

        elif current_matrix == 1:  # X (gap in seq1)
            if X[i][j] == M[i][j-1] + gap_open:
                current_matrix = 0
            else:
                current_matrix = 1

            align1 = "-" + align1
            align2 = seq2[j-1] + align2
            j -= 1

        else:  # Y (gap in seq2)
            if Y[i][j] == M[i-1][j] + gap_open:
                current_matrix = 0
            else:
                current_matrix = 2

            align1 = seq1[i-1] + align1
            align2 = "-" + align2
            i -= 1

    return align1, align2, final_score

if __name__ == "__main__":

    seq1 = read_fasta("files/seq1.fasta")
    seq2 = read_fasta("files/seq2.fasta")

    gap_open, gap_extend, score_mat = read_csv("files/scoring.csv")

    aln1, aln2, score = affine_global_alignment(
        seq1,
        seq2,
        gap_open,
        gap_extend,
        score_mat
    )

    print("Alignment Score:", score)
    print(aln1)
    print(aln2)