# -*- coding: utf-8 -*-
"""BBL434_Assignment-1_Naman_Kohli.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RgeONxsa3meJru5qAcQrcmGqVC1SQHF1

The universal plasmid maker will contain the following features, assuming the only inputs allowed are:

1. Input.fa containing DNA Sequence
2. Design.txt containing X Restriction Enzymes with their sites and Y Antibiotic markers with names

Replication Core (OriV, RepA, RepB, RepC) [Independent of Host]

Spacer 1

Antibiotic Resistance Markers

Spacer 2

Multiple Cloning Site (All Restriction Enzyme Sites)

Spacer 3

Origin of Transfer [For Conjugative Transfer]

Spacer 4

Back to Replication Core
"""

import random
import itertools

def read_fasta(f):
  seq = []
  with open(f,'r') as dnaf:
    for i in dnaf.readlines():
      seq.append(i.strip())
  return ''.join(seq)

def read_txt(f):
  RE = {}
  ABX = {}
  with open(f,'r') as reabx:
    for x in reabx.readlines():
      y = x.strip().split(", ")
      if len(y[0])<=10:
        RE[y[1]] = y[0]
      else:
        ABX[y[1]] = y[0]
  return RE,ABX

def creates_forbidden_site(x,y):
  for item in y:
    if item in x:
      return True
  else:
    return False

def generate_spacer(length, forbidden_sites):
    spacer = ""
    while len(spacer) < length:
        spacer += random.choice(["A", "T"])
        if creates_forbidden_site(spacer, forbidden_sites):
            spacer = spacer[:-1]
    return spacer

def ab_markers(abx):
  ABXS = ""
  for AB in abx.values():
    ABXS+=AB # Assuming that the markers contain promoter and terminator regions for each antibiotic, since we do not know in advance what the antibiotic is
  return ABXS

def mcs(re):
  MCS = ""
  for RE in re.values():
    MCS+=RE
    spac_len = random.randrange(2,5)
    small_spacer = generate_spacer(spac_len,re.values())
    MCS+=small_spacer
  return MCS

def final_plasmid_checker(OriV, RepA, RepB, RepC, ABXS, MCS, OriT,
                           spacer_1, spacer_2, spacer_3, spacer_4,
                           re_dict, abx_dict):

    RE_sites = list(re_dict.values())

    report = {
        "status": "PASS",
        "errors": [],
        "ABXS_used": ABXS
    }

    # ---------- helper wrappers (built on your code) ----------

    def re_hits(seq):
        """Return list of RE sites present in seq"""
        return [site for site in RE_sites if site in seq]

    def has_RE(seq):
        """Boolean check using user's helper"""
        return creates_forbidden_site(seq, RE_sites)

    def junction(a, b, k=12):
        return a[-k:] + b[:k]

    # ---------- protected regions ----------
    protected = {
        "OriV": OriV,
        "RepC": RepC,
        "RepA": RepA,
        "RepB": RepB,
        "OriT": OriT
    }

    for name, seq in protected.items():
        if has_RE(seq):
            report["status"] = "FAIL"
            report["errors"].append(
                f"Restriction site(s) {re_hits(seq)} found in protected region {name}"
            )

    # ---------- antibiotic markers (reorder-only logic) ----------
    abx_seqs = list(abx_dict.values())
    valid_ABXS = None

    for perm in itertools.permutations(abx_seqs):
        candidate = "".join(perm)
        if not has_RE(candidate):
            valid_ABXS = candidate
            break

    if valid_ABXS is None:
        report["status"] = "FAIL"
        report["errors"].append(
            "Restriction site found in antibiotic marker(s); "
            "no valid reordering possible"
        )
    else:
        report["ABXS_used"] = valid_ABXS

    # ---------- MCS: exactly once ----------
    for site in RE_sites:
        if MCS.count(site) != 1:
            report["status"] = "FAIL"
            report["errors"].append(
                f"Restriction site {site} occurs {MCS.count(site)} times in MCS"
            )

    # ---------- junction checks (including circular) ----------
    blocks = [
        OriV,
        RepC,
        RepA,
        RepB,
        spacer_1,
        report["ABXS_used"],
        spacer_2,
        MCS,
        spacer_3,
        OriT,
        spacer_4
    ]

    for i in range(len(blocks)):
        junc = junction(blocks[i], blocks[(i + 1) % len(blocks)])
        if has_RE(junc):
            if i!=7 and i!=6:
              blocks[i+1] = generate_spacer(3,re.values()) + blocks[i+1]
              new_junc = junction(blocks[i], blocks[(i + 1) % len(blocks)])
              if has_RE(new_junc):
                report["status"] = "FAIL"
                report["errors"].append(
                    f"Restriction site(s) {re_hits(new_junc)} formed at junction {i}â†’{i+1}")
    if report['status'] == "PASS":
      return ''.join(blocks)
    return report

# GenBank: M35512.1 Ori from Plasmid R1162
OriV = "CCGGGCTGAATGATCGACCGAGACAGGCCCTGCGGGGCTGCACACGCGCCCCCACCCTTCGGGTAGGGGGAAAGGCCGCTAAAGCGGCTAAAAGCGCTCCAGCGTATTTCTGCGGGGTTTGGTGTGGGGTTTAGCGGGCTTTGCCCGCCTTTCCCCCTGCCGCGCAGCGGTGGGGCGGTGTGTAGCCTAGCGCAGCGAATAGACCAGCTATCCGGCCTCTGGGCATATTGGGCAGGGCAGCAGCGCCCCACAGGGCGTGACTAACCGCGCCTAGTGGATTATTCTTAGATAATCATGGATGGATTTTTCCAACACCCCGCCAGCCCCCGCCCCTGCTGGGTTTGCAGGTTTGGGGGCGTGACAGTTATTGCAGGGGTTCGTGACAGTTATTGCAGGGGGGCGTGACAGTTATTGCAGGGGTTCGTGACAGTTAGTACGGGATGACGGGCACTGGCTGGCAATGTCTAGCAACGGCAGGCATGTCGGCTGACGGTAAAACAACTTTCCGCTAAGCGATAGACTGTATGTGAAACACAGTATTGCAAGGACGCGGAACATGCCTCATGTGGCGGCCAGGACGGCCAGCCGG"

# GenBank: M28829.1 Rep proteins from Plasmid RSF1010 from same Plasmid family as R1162 (IncQ)

# Origin Binding Initiator
RepC = "GTGGTGAAGCCTAAGAACAAGCACAGCCTCAGCCACGTCCGGCACGACCCGGCGCACTGTCTGGCCCCCGGCCTGTTCCGTGCCCTCAAGCGGGGCGAGCGCAAGCGCAGCAAGCTGGACGTGACGTATGACTACGGCGACGGCAAGCGGATCGAGTTCAGCGGCCCGGAGCCGCTGGGCGCTGATGATCTGCGCATCCTGCAAGGGCTGGTGGCCATGGCTGGGCCTAATGGCCTAGTGCTTGGCCCGGAACCCAAGACCGAAGGCGGACGGCAGCTCCGGCTGTTCCTGGAACCCAAGTGGGAGGCCGTCACCGCTGAATGCCATGTGGTCAAAGGTAGCTATCGGGCGCTGGCAAAGGAAATCGGGGCAGAGGTCGATAGTGGTGGGGCGCTCAAGCACATACAGGACTGCATCGAGCGCCTTTGGAAGGTATCCATCATCGCCCAGAATGGCCGCAAGCGGCAGGGGTTTCGGCTGCTGTCGGAGTACGCCAGCGACGAGGCGGACGGGCGCCTGTACGTGGCCCTGAACCCCTTGATCGCGCAGGCCGTCATGGGTGGCGGCCAGCATGTGCGCATCAGCATGGACGAGGTGCGGGCGCTGGACAGCGAAACCGCCCGCCTGCTGCACCAGCGGCTGTGTGGCTGGATCGACCCCGGCAAAACCGGCAAGGCTTCCATAGATACCTTGTGCGGCTATGTCTGGCCGTCAGAGGCCAGTGGTTCGACCATGCGCAAGCGCCGCCAGCGGGTGCGCGAGGCGTTGCCGGAGCTGGTCGCGCTGGGCTGGACGGTAACCGAGTTCGCGGCGGGCAAGTACGACATCACCCGGCCCAAGGCGGCAGGCTGA"
# Helicase
RepA = "ATGGCTACCCATAAGCCTATCAATATTCTGGAGGCGTTCGCAGCAGCGCCGCCACCGCTGGACTACGTTTTGCCCAACATGGTGGCCGGTACGGTCGGGGCGCTGGTGTCGCCCGGTGGTGCCGGTAAATCCATGCTGGCCCTGCAACTGGCCGCACAGATTGCAGGCGGGCCGGATCTGCTGGAGGTGGGCGAACTGCCCACCGGCCCGGTGATCTACCTGCCCGCCGAAGACCCGCCCACCGCCATTCATCACCGCCTGCACGCCCTTGGGGCGCACCTCAGCGCCGAGGAACGGCAAGCCGTGGCTGACGGCCTGCTGATCCAGCCGCTGATCGGCAGCCTGCCCAACATCATGGCCCCGGAGTGGTTCGACGGCCTCAAGCGCGCCGCCGAGGGCCGCCGCCTGATGGTGCTGGACACGCTGCGCCGGTTCCACATCGAGGAAGAAAACGCCAGCGGCCCCATGGCCCAGGTCATCGGTCGCATGGAGGCCATCGCCGCCGATACCGGGTGCTCTATCGTGTTCCTGCACCATGCCAGCAAGGGCGCGGCCATGATGGGCGCAGGCGACCAGCAGCAGGCCAGCCGGGGCAGCTCGGTACTGGTCGATAACATCCGCTGGCAGTCCTACCTGTCGAGCATGACCAGCGCCGAGGCCGAGGAATGGGGTGTGGACGACGACCAGCGCCGGTTCTTCGTCCGCTTCGGTGTGAGCAAGGCCAACTATGGCGCACCGTTCGCTGATCGGTGGTTCAGGCGGCATGACGGCGGGGTGCTCAAGCCCGCCGTGCTGGAGAGGCAGCGCAAGAGCAAGGGGGTGCCCCGTGGTGAAGCCTAA"
# Primase
RepB = "ATGAAGAACGACAGGACTTTGCAGGCCATAGGCCGACAGCTCAAGGCCATGGGCTGTGAGCGCTTCGATATCGGCGTCAGGGACGCCACCACCGGCCAGATGATGAACCGGGAATGGTCAGCCGCCGAAGTGCTCCAGAACACGCCATGGCTCAAGCGGATGAATGCCCAGGGCAATGACGTGTATATCAGGCCCGCCGAGCAGGAGCGGCATGGTCTGGTGCTGGTGGACGACCTCAGCGAGTTTGACCTGGATGACATGAAAGCCGAGGGCCGGGAGCCTGCCCTGGTAGTGGAAACCAGCCCGAAGAACTATCAGGCATGGGTCAAGGTGGCCGACGCCGCAGGCGGTGAACTTCGGGGGCAGATTGCCCGGACGCTGGCCAGCGAGTACGACGCCGACCCGGCCAGCGCCGACAGCCGCCACTATGGCCGCTTGGCGGGCTTCACCAACCGCAAGGACAAGCACACCACCCGCGCCGGTTATCAGCCGTGGGTGCTGCTGCGTGAATCCAAGGGCAAGACCGCCACCGCTGGCCCGGCGCTGGTGCAGCAGGCTGGCCAGCAGATCGAGCAGGCCCAGCGGCAGCAGGAGAAGGCCCGCAGGCTGGCCAGCCTCGAACTGCCCGAGCGGCAGCTTAGCCGCCACCGGCGCACGGCGCTGGACGAGTACCGCAGCGAGATGGCCGGGCTGGTCAAGCGCTTCGGTGATGACCTCAGCAAGTGCGACTTTATCGCCGCGCAGAAGCTGGCCAGCCGGGGCCGCAGTGCCGAGGAAATCGGCAAGGCCATGGCCGAGGCCAGCCCAGCGCTGGCAGAGCGCAAGCCCGGCCACGAAGCGGATTACATCGAGCGCACCGTCAGCAAGGTCATGGGTCTGCCCAGCGTCCAGCTTGCGCGGGCCGAGCTGGCACGGGCACCGGCACCCCGCCAGCGAGGCATGGACAGGGGCGGGCCAGATTTCAGCATGTAG"
# DNA Origin of Transfer
OriT = "GGCCAGTTTCTCGAAGAGAAACCGGTAAATGCGCCCTCCCCTACAAAGTAGGGTCGGGATTGCCGCCGCTGTGCCTCCATGATAGCCTACGAGACAGCACATTAACAATGGGGTGTCAAGATGGTTAAGGGGAGCAACAAGGCGGCGGATCGGCTGGCCA"

dna = read_fasta('input.fa')
re,abx = read_txt('design.txt')

spacer_1 = generate_spacer(37,re.values())
spacer_2 = generate_spacer(24,re.values())
spacer_3 = generate_spacer(41,re.values())
spacer_4 = generate_spacer(29,re.values())

ABXS = ab_markers(abx)
MCS = mcs(re)

plasmid_seq = OriV + RepC + RepA + RepB + spacer_1 + ABXS + spacer_2 + MCS + spacer_3 + OriT + spacer_4
rep = final_plasmid_checker(OriV, RepA, RepB, RepC, ABXS, MCS, OriT, spacer_1, spacer_2, spacer_3, spacer_4, re, abx)
if len(rep) == 3:
  print(rep)
else:
  plasmid_seq = rep

with open('Output.fa','w') as out:
  out.write(">New Plasmid\n"+plasmid_seq)

