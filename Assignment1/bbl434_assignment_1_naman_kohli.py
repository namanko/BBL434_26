# -*- coding: utf-8 -*-
"""BBL434_Assignment-1_Naman_Kohli.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RgeONxsa3meJru5qAcQrcmGqVC1SQHF1

The universal plasmid maker will contain the following features, assuming the only inputs allowed are:

1. Input.fa containing DNA Sequence
2. Design.txt containing X Restriction Enzymes with their sites and Y Antibiotic markers with names

OriC [Host DnaA binds Ori and initiates replication]

Spacer 1

Antibiotic Resistance Markers

Spacer 2

Multiple Cloning Site (All Restriction Enzyme Sites)

Spacer 3

Origin of Transfer [For Conjugative Transfer]

Spacer 4

Back to OriC
"""

import random
import itertools

# To read the DNA Sequence of Organism
def read_fasta(f):
  seq = []
  with open(f,'r') as dnaf:
    for i in dnaf.readlines():
      seq.append(i.strip())
  return ''.join(seq)

# To read Design file containing RE sites and Antibiotics
# Assumption: Sequence will be provided inside this file
def read_txt(f):
  RE = {}
  ABX = {}
  with open(f,'r') as reabx:
    for x in reabx.readlines():
      y = x.strip().split(", ")
      if len(y[0])<=10:
        RE[y[1]] = y[0]
      else:
        ABX[y[1]] = y[0]
  return RE,ABX

#Cumulative GC Skew calculation
def GCSkew(genome,L,step):
  totalskew = []
  pos = []
  currskew = 0
  for i in range(0,len(genome)-L, step):
    window = genome[i:i+L]
    numG = 0
    numC = 0
    for base in window:
      if base == 'G':
        numG +=1
      elif base == 'C':
        numC +=1
    if numG==numC==0:
      totalskew.append(0)
    else:
      currskew += (numG-numC)/(numG+numC)
      totalskew.append(currskew)
      pos.append(i +  (L//2))
  return pos, totalskew

# Finding window of minimum GC Skew (Window containing Ori)
def OriFinder(genome,L,step):
  posSkew, gcSkew = GCSkew(genome,L,step)

  ms = min(gcSkew)
  mposS = posSkew[gcSkew.index(ms)]

  lower = mposS - (L//2)
  upper = mposS + (L//2) + 1
  return genome[lower:upper]

# Helper function to calculate 'AT' fraction in a given window
def at_fraction(window):
   at = sum(1 for b in window if b in "AT")
   return at / len(window)

# Helper function to get an idea of 'AT' fraction in a given sequence
def genome_at_signal(genome, L=80, step=5):
  coords = []
  signal = []
  for i in range(0, len(genome) - L + 1, step):
    window = genome[i:i+L]
    at = at_fraction(window)
    coords.append(i + L // 2)
    signal.append(at)
  return coords, signal

# Finds the midpoint of DNA Unwinding element of Ori
def find_due_mid(coords, signal, delta=0.15):
    threshold = sum(signal) / len(signal) + delta

    runs = []
    in_run = False
    start = None

    for i, val in enumerate(signal):
        if val >= threshold:
            if not in_run:
                start = i
                in_run = True
        else:
            if in_run:
                runs.append((start, i - 1))
                in_run = False

    if in_run:
        runs.append((start, len(signal) - 1))

    if not runs:
        return None

    # pick longest run
    best = max(runs, key=lambda r: coords[r[1]] - coords[r[0]])

    start_i, end_i = best
    due_mid = (coords[start_i] + coords[end_i]) // 2

    return due_mid

# Helper function to check if RE site is present in given sequence or not
def creates_forbidden_site(x,y):
  for item in y:
    if item in x:
      return True
  else:
    return False

# Helper function to generate random spacers of AT of given length
def generate_spacer(length, forbidden_sites):
    spacer = ""
    while len(spacer) < length:
        spacer += random.choice(["A", "T"])
        if creates_forbidden_site(spacer, forbidden_sites):
            spacer = spacer[:-1]
    return spacer

# Sequence containing all antibiotic markers
# Assumption: all markers contain their promoter and terminator regions already
def ab_markers(abx):
  ABXS = ""
  for AB in abx.values():
    ABXS+=AB
  return ABXS

# Multiple Cloning Site containing all RE Sites
def mcs(re):
  MCS = ""
  for RE in re.values():
    MCS+=RE
    spac_len = random.randrange(2,5)
    small_spacer = generate_spacer(spac_len,re.values())
    MCS+=small_spacer
  return MCS

# Final checker function to ensure RE sites are present only once in the MCS and not anywhere else
def final_plasmid_checker(OriC, ABXS, MCS, OriT,
                           spacer_1, spacer_2, spacer_3, spacer_4,
                           re_dict, abx_dict):

    RE_sites = list(re_dict.values())

    report = {
        "status": "PASS",
        "errors": [],
        "ABXS_used": ABXS
    }

    # ---------- helper wrappers ----------

    def re_hits(seq):
        """Return list of RE sites present in seq"""
        return [site for site in RE_sites if site in seq]

    def has_RE(seq):
        """Boolean check using user's helper"""
        return creates_forbidden_site(seq, RE_sites)

    def junction(a, b, k=12):
        return a[-k:] + b[:k]

    # ---------- protected regions ----------
    protected = {
        "OriC": OriC,
        "OriT": OriT
    }

    for name, seq in protected.items():
        if has_RE(seq):
            report["status"] = "FAIL"
            report["errors"].append(
                f"Restriction site(s) {re_hits(seq)} found in protected region {name}"
            )

    # ---------- antibiotic markers (reordering logic) ----------
    abx_seqs = list(abx_dict.values())
    valid_ABXS = None

    for perm in itertools.permutations(abx_seqs):
        candidate = "".join(perm)
        if not has_RE(candidate):
            valid_ABXS = candidate
            break

    if valid_ABXS is None:
        report["status"] = "FAIL"
        report["errors"].append(
            "Restriction site found in antibiotic marker(s); "
            "no valid reordering possible"
        )
    else:
        report["ABXS_used"] = valid_ABXS

    # ---------- MCS: exactly once ----------
    for site in RE_sites:
        if MCS.count(site) != 1:
            report["status"] = "FAIL"
            report["errors"].append(
                f"Restriction site {site} occurs {MCS.count(site)} times in MCS"
            )

    # ---------- junction checks (including circular) ----------
    blocks = [
        OriC,
        spacer_1,
        report["ABXS_used"],
        spacer_2,
        MCS,
        spacer_3,
        OriT,
        spacer_4
    ]

    for i in range(len(blocks)):
        junc = junction(blocks[i], blocks[(i + 1) % len(blocks)])
        if has_RE(junc):
            if i!=3 and i!=4:
              blocks[i] += generate_spacer(3,re.values())
              new_junc = junction(blocks[i], blocks[(i + 1) % len(blocks)])
              if has_RE(new_junc):
                report["status"] = "FAIL"
                report["errors"].append(
                    f"Restriction site(s) {re_hits(new_junc)} formed at junction {i}â†’{i+1}")
    if report['status'] == "PASS":
      return ''.join(blocks)
    return report

dna = read_fasta('./Test_Cases/input.fa')
re,abx = read_txt('./Test_Cases/design.txt')

L = 5000
step = 50
OriC = OriFinder(dna,L,step)
coords, at = genome_at_signal(OriC, L=80, step=5)

due_mid = find_due_mid(coords, at)

ori_start = max(0, due_mid - 300)
ori_end   = min(len(OriC), due_mid + 300)

# Setting Ori as 300 bp upstream and downstream of midpoint of DNA Unwinding Element
ORI = OriC[ori_start:ori_end]


# DNA Origin of Transfer for plasmid R1162 (based on the paper)
OriT = "GGCCAGTTTCTCGAAGAGAAACCGGTAAATGCGCCCTCCCCTACAAAGTAGGGTCGGGATTGCCGCCGCTGTGCCTCCATGATAGCCTACGAGACAGCACATTAACAATGGGGTGTCAAGATGGTTAAGGGGAGCAACAAGGCGGCGGATCGGCTGGCCA"

spacer_1 = generate_spacer(37,re.values())
spacer_2 = generate_spacer(24,re.values())
spacer_3 = generate_spacer(41,re.values())
spacer_4 = generate_spacer(29,re.values())

ABXS = ab_markers(abx)
MCS = mcs(re)

# Constructing final plasmid sequence
plasmid_seq = ORI + spacer_1 + ABXS + spacer_2 + MCS + spacer_3 + OriT + spacer_4
rep = final_plasmid_checker(ORI, ABXS, MCS, OriT, spacer_1, spacer_2, spacer_3, spacer_4, re, abx)

# Error handling
if len(rep) == 3:
  print(rep)
else:
  plasmid_seq = rep
  with open('./Test_Cases/Output.fa','w') as out:
    out.write(">New Plasmid\n"+plasmid_seq)

